

/***********************************************************************//**
  \file   ultrasonicWind.ino
  \brief  NMEA2000 base file for ultrasonicWind. Send main data to the bus.
 

  This base file sends wind data
  to the NMEA2000 bus and exposes it over wifi/html

  Does not fullfill all NMEA2000 requirements.
*/



//#define N2k_SPI_CS_PIN 53    // If you use mcp_can and CS pin is not 53, uncomment this and modify definition to match your CS pin.
//#define N2k_CAN_INT_PIN 21   // If you use mcp_can and interrupt pin is not 21, uncomment this and modify definition to match your interrupt pin.
//#define USE_MCP_CAN_CLOCK_SET 8  // If you use mcp_can and your mcp_can shield has 8MHz chrystal, uncomment this.
#define ESP32_CAN_TX_PIN GPIO_NUM_21 // If you use ESP32 and do not have TX on default IO 16, uncomment this and and modify definition to match your CAN TX pin.
#define ESP32_CAN_RX_PIN GPIO_NUM_20 // If you use ESP32 and do not have RX on default IO 4, uncomment this and and modify definition to match your CAN RX pin.
#define ESP32_MOD_RX_PIN GPIO_NUM_2  //modbus RX
#define ESP32_MOD_TX_PIN GPIO_NUM_0  //modbux TX

#define LED_BLUE 8 // blue LED pin 
#include <Arduino.h>
//#define NMEA2000_ARDUINO_DUE_CAN_BUS tNMEA2000_due::CANDevice1  // If you use Arduino DUE and want to use CAN bus 1 instead of 0, uncomment this.
//#define NMEA2000_TEENSY_CAN_BUS 1 // If you use Teensy 3.5 or 3.6 and want to use second CAN bus, uncomment this.
#include <N2kMsg.h>
#include <NMEA2000_CAN.h>  // This will automatically choose right CAN library and create suitable NMEA2000 object
#include <N2kMessages.h>
#include <Modbus.h>
#include <HardwareSerial.h>
#include <esp_mac.h>
#include <Preferences.h>
//web server
#include <WiFi.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <LittleFS.h>
#include <Arduino_JSON.h>
#include <zenoh-pico.h>



//modbus
#define MODBUS_SLAVE_ID 1    //default is 0xFF, change via modbus-cli, ~/.local/bin/modbus -s 0 -b 9600 /dev/ttyUSB0 0=1 -v
#define MODBUS_TIMEOUT 50
#define WIND_SPEED_REG 0x000C  // Assuming starting register address for wind speed
#define DIRECTION_REG 0x000D   // Assuming starting register address for direction
#define MODE 5                 //DE/RE pin, not used
#define DEBUG 0

int seq = 0; //SID
int aws_raw = 0;
int awa_raw = 0;
float aws_ms = 0;
float aws = 0;  //knots
float awa = 0;  //deg 0 to 360 from bow
float last_awa = 0; 
long t = 0;
bool blink = LOW;

//n2k
Preferences preferences;             // Nonvolatile storage on ESP32 - To store LastDeviceAddress
int nodeAddress;  // To store last Node Address

//web server
// Replace with your network credentials
const char* ssid = "Foxglove-2g";
const char* password = "foxglove16.4";

// Create AsyncWebServer object on port 80
AsyncWebServer server(80);

// Create an Event Source on /events
AsyncEventSource events("/events");

// Json Variable to Hold Sensor Readings
JSONVar readings;

// Timer variables
unsigned long lastTime = 0;
unsigned long timerDelay = 1000;

//modbus
HardwareSerial modSerial(1);

Modbus modbus(modSerial);

// List here messages your device will transmit. Default: wind
const unsigned long transmitMessages[] PROGMEM={130306L,0};

// Define schedulers for messages. Define schedulers here disabled. Schedulers will be enabled
// on OnN2kOpen so they will be synchronized with system.
// We use own scheduler for each message so that each can have different offset and period.
// Setup periods according PGN definition (see comments on IsDefaultSingleFrameMessage and
// IsDefaultFastPacketMessage) and message first start offsets. Use a bit different offset for
// each message so they will not be sent at same time.
tN2kSyncScheduler windScheduler(false,100,500);

// *****************************************************************************
// Call back for NMEA2000 open. This will be called, when library starts bus communication.
// See NMEA2000.SetOnOpen(OnN2kOpen); on setup()
void OnN2kOpen() {
  // Start schedulers now.
  windScheduler.UpdateNextTime();
}

int getStoredNodeAddress(){
  preferences.begin("nvs", false);                          // Open nonvolatile storage (nvs)
  nodeAddress = preferences.getInt("LastNodeAddress", 23);  // Read stored last nodeAddress, default 23
  preferences.end();
  Serial.printf("nodeAddress=%d\n", nodeAddress);
  return nodeAddress;
}

uint32_t getUniqueId(){
  //get unique id based on chip id
  uint8_t chipid[6];
  uint32_t id = 0;
  int i = 0;
  esp_efuse_mac_get_default(chipid);
  for (i = 0; i < 6; i++) id += (chipid[i] << (7 * i));
  return id;
}

// Get Sensor Readings and return JSON object
String getSensorReadings(){
  readings["awa"] = deAverageAwa(); //String(bme.readTemperature());
  readings["aws"] =  aws; //String(bme.readHumidity());
  String jsonString = JSON.stringify(readings);
  return jsonString;
}

// Initialize LittleFS
void initLittleFS() {
  if (!LittleFS.begin()) {
    Serial.println("An error has occurred while mounting LittleFS");
  }
  Serial.println("LittleFS mounted successfully");
}

void WiFiStationConnected(WiFiEvent_t event, WiFiEventInfo_t info){
  Serial.println("Connected to AP successfully!");
}

void WiFiGotIP(WiFiEvent_t event, WiFiEventInfo_t info){
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}

void WiFiStationDisconnected(WiFiEvent_t event, WiFiEventInfo_t info){
  Serial.println("Disconnected from WiFi access point");
  Serial.print("WiFi lost connection. Reason: ");
  Serial.println(info.wifi_sta_disconnected.reason);
  Serial.println("Trying to Reconnect");
  WiFi.begin(ssid, password);
  WiFi.setTxPower(WIFI_POWER_15dBm);
}

// Initialize WiFi
void initWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  delay(100);
  Serial.println();
  Serial.print("Scanning networks ");
  int n = WiFi.scanNetworks();
  Serial.println("Done. Printing network list ");
  for (int i = 0; i < n; i++)
  {
    Serial.print(WiFi.SSID(i));
    Serial.print("  ");
     Serial.println(WiFi.RSSI(i));
  }
  WiFi.scanComplete();
    // delete old config
  WiFi.disconnect(true);

  delay(1000);

  WiFi.onEvent(WiFiStationConnected, WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_CONNECTED);
  WiFi.onEvent(WiFiGotIP, WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_GOT_IP);
  WiFi.onEvent(WiFiStationDisconnected, WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_DISCONNECTED);

  //WiFi.setHostname("wind");
  WiFi.begin(ssid, password);
  WiFi.setTxPower(WIFI_POWER_15dBm);
  Serial.print("Connecting to WiFi ..");
  // int x = 0;
  // while (WiFi.status() != WL_CONNECTED) {
  //   Serial.print('.');
  //   delay(100);
  //   if(x>500){
  //     Serial.println(" failed to connect, retrying");
  //     x=0;
  //     //ESP.restart();
  //   }
  //   x++;
  // }
  
}

void initWebServer(){
   // Web Server Root URL
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(LittleFS, "/index.html", "text/html");
  });

  server.serveStatic("/", LittleFS, "/");

  // Request for the latest sensor readings
  server.on("/readings", HTTP_GET, [](AsyncWebServerRequest *request){
    String json = getSensorReadings();
    request->send(200, "application/json", json);
    json = String();
  });

  events.onConnect([](AsyncEventSourceClient *client){
    if(client->lastId()){
      Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
    }
    // send event with message "hello!", id current millis
    // and set reconnect delay to 10 seconds
    client->send("hello!", NULL, millis(), 10000);
  });
  server.addHandler(&events);

  // Start server
  server.begin();
}

void initN2K(){
  // Set Product information
  NMEA2000.SetProductInformation("00000002", // Manufacturer's Model serial code
                                 100, // Manufacturer's product code
                                 "Simple wind monitor",  // Manufacturer's Model ID
                                 "1.2.0.24 (2022-10-01)",  // Manufacturer's Software version code
                                 "1.2.0.0 (2022-10-01)" // Manufacturer's Model version
                                 );
  // Set device information note old codes function 180, class 80
  NMEA2000.SetDeviceInformation(getUniqueId(), // Unique number. Use e.g. Serial number.
                                130, // Device function=Atmospheric. See codes on https://web.archive.org/web/20190531120557/https://www.nmea.org/Assets/20120726%20nmea%202000%20class%20&%20function%20codes%20v%202.00.pdf
                                85, // Device class=External Environment. See codes on https://web.archive.org/web/20190531120557/https://www.nmea.org/Assets/20120726%20nmea%202000%20class%20&%20function%20codes%20v%202.00.pdf
                                140 // Just choosen free from code list on https://web.archive.org/web/20190529161431/http://www.nmea.org/Assets/20121020%20nmea%202000%20registration%20list.pdf
                               );
  // Uncomment row below to see, what device will send to bus. Use e.g. OpenSkipper or Actisense NMEA Reader                           
  NMEA2000.SetForwardStream(&Serial);
  // If you want to use simple ascii monitor like Arduino Serial Monitor, uncomment next line
  NMEA2000.SetForwardType(tNMEA2000::fwdt_Text); // Show in clear text. Leave uncommented for default Actisense format.

  // get last node address
  nodeAddress = getStoredNodeAddress(); // Read stored last nodeAddress, default 23

  // If you also want to see all traffic on the bus use N2km_ListenAndNode instead of N2km_NodeOnly below
  NMEA2000.SetMode(tNMEA2000::N2km_ListenAndNode,nodeAddress);
  //NMEA2000.SetDebugMode(tNMEA2000::dm_Actisense); // Uncomment this, so you can test code without CAN bus chips on Arduino Mega
  NMEA2000.EnableForward(true);
  // Here we tell library, which PGNs we transmit
  NMEA2000.ExtendTransmitMessages(transmitMessages);
  // Define OnOpen call back. This will be called, when CAN is open and system starts address claiming.
  NMEA2000.SetOnOpen(OnN2kOpen);
}

void setup() {

  Serial.begin(115200);
  
  initN2K();

  // Initialize Modbus communication on serial 1
  modSerial.begin(9600, SERIAL_8N1, ESP32_MOD_RX_PIN, ESP32_MOD_TX_PIN);
  modbus.init(MODE, false);
  modbus.setTimeout(MODBUS_TIMEOUT);
  t=millis();
    // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BLUE, OUTPUT);
  digitalWrite(LED_BLUE, LOW);
  NMEA2000.Open();

  initWiFi();
  initLittleFS();
  initWebServer();
}


// *****************************************************************************
void loop() {
  queryModbus();
  sendN2kWind();
  NMEA2000.ParseMessages();
  //check node address
  checkNodeAddress();
  updateWebPage();
}

void updateWebPage(){
  if ((millis() - lastTime) > timerDelay) {
    // Send Events to the client with the Sensor Readings Every 1 second
    events.send("ping",NULL,millis());
    events.send(getSensorReadings().c_str(),"new_readings" ,millis());
    lastTime = millis();
  }
}
void checkNodeAddress(){
   int sourceAddress = NMEA2000.GetN2kSource();
  if (sourceAddress != nodeAddress) { // Save potentially changed Source Address to NVS memory
    nodeAddress = sourceAddress;      // Set new Node Address (to save only once)
    preferences.begin("nvs", false);
    preferences.putInt("LastNodeAddress", sourceAddress);
    preferences.end();
    Serial.printf("Address Change: New Address=%d\n", sourceAddress);
  }
}

void queryModbus() {
  //no more than 1 per sec
  if((millis()-t)<999L){
    return;
  }
  blink=!blink;
  digitalWrite(LED_BLUE, blink);
  t=millis();
  if(DEBUG)Serial.println("Query modbus");
  // Query Modbus slave
  if (modbus.requestFrom(MODBUS_SLAVE_ID, 0x03, WIND_SPEED_REG, 2) > 0) {
    // Successfully read from slave, process data
    if(DEBUG)Serial.println(" found..");
    aws_raw = modbus.uint16(0);  // Read wind speed, m/s * 100, aka 293 = 2.93m/s
    aws_ms = aws_raw / 100.0;
    aws = aws_ms * 1.943844;     //knots
    awa_raw = modbus.uint16(1);  // Read direction, deg clockwise from N mark. deg *10, eg 2345 = 234.5deg
    //awa = (awa_raw / 10.0) - 180.0;
    last_awa = awa;
    awa = (awa_raw / 10.0);
  } else {
    // Failed to read, handle error or retry
    //  Serial.println(modbusClient.lastError());
    Serial.println("Modbus read failed, retrying...");
  }
}

void incrementSeq(){
    seq++;
    if(seq == 255) seq = 1;
  }
/*
* Try to make awa more responsive by doubling the change from last value, as the sensor does moving averages over about 3 secs.
* Should make the needle follow wind faster, at the cost of a second or two of overshoot/undershoot. 
*/
  
float deAverageAwa(){
  float diff = awa - last_awa;
  float new_awa = awa + diff;
  if(new_awa >= 360) new_awa = new_awa-360;
  if(new_awa <0) new_awa = new_awa + 360;
  //Serial.print("last_awa = ");
  //Serial.print(last_awa);
  //Serial.print(", awa = ");
  //Serial.print(awa);
  //Serial.print(", diff = ");
  //Serial.print(diff);
  //Serial.print(", new_awa = ");
  //Serial.println(new_awa);
  return new_awa;
}


// *****************************************************************************
double readWindAngle() {
  return DegToRad(deAverageAwa()); // Read here the measured wind angle e.g. from analog input
}

// *****************************************************************************
double readWindSpeed() {
  //in m/s
  return aws_ms; // Read here the wind speed e.g. from analog input
}

// *****************************************************************************
void sendN2kWind() {
  tN2kMsg N2kMsg;

  if ( windScheduler.IsTime() ) {
    windScheduler.UpdateNextTime();
    SetN2kWindSpeed(N2kMsg, seq, readWindSpeed(), readWindAngle(),N2kWind_Apprent);
    if(NMEA2000.SendMsg(N2kMsg)){
      Serial.print("Bus ID: ");
      Serial.print(NMEA2000.GetN2kSource());
      Serial.println(" sent n2k message");
    }
    incrementSeq();
  }

  
}

